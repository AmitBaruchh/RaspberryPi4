import cv2
import pygame
import numpy as np

# Set up the Raspberry Pi and cameras

# Open both cameras
cap0 = cv2.VideoCapture(0)
cap1 = cv2.VideoCapture(1)

# Set the frames per second (FPS) for the video stream
fps = 30

# Set the dimensions of the captured frames
frame_width = 640
frame_height = 480

# Set the dimensions of the combined frame
combined_width = frame_width * 2
combined_height = frame_height

# Initialize the combined frame
combined = np.zeros((combined_height, combined_width, 3), dtype=np.uint8)

while True:
    # Capture a frame from each camera
    ret0, frame0 = cap0.read()
    ret1, frame1 = cap1.read()

    # Check if the frames were successfully captured
    if not (ret0 and ret1):
        break

    # Resize the frames to the desired dimensions
    frame0 = cv2.resize(frame0, (frame_width, frame_height))
    frame1 = cv2.resize(frame1, (frame_width, frame_height))

    # Combine the frames side by side
    combined[:, :frame_width] = frame0
    combined[:, frame_width:] = frame1

    # Convert the combined frame to grayscale
    gray = cv2.cvtColor(combined, cv2.COLOR_BGR2GRAY)

    # Detect edges using the Canny algorithm
    edges = cv2.Canny(gray, 50, 150)

    # Apply a morphological transformation to fill in gaps and eliminate noise
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    closed = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, kernel)

    # Check if there are any obstacles detected
    if cv2.countNonZero(closed) > 0:
        # Play a warning sound using pygame
        pygame.init()
        pygame.mixer.music.load("warning.mp3")
        pygame.mixer.music.play()

    # Display the combined frame
    cv2.imshow('Combined', combined)

    # Check if the user pressed 'q' to quit
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release both cameras
cap0.release()
cap1.release()

# Close all windows
cv2.destroyAllWindows()



    # Compute the disparity map using the stereoBM or stereoSGBM function from the cv2 library
    stereo = cv2.StereoBM_create(numDisparities=16, blockSize=15)
    disparity = stereo.compute(frame0, frame1)


Regarding motion detection, you can use the following code

Copy code
    # compute the difference between the current frame and the previous frame
    frame_diff = cv2.absdiff(frame0, frame1)
    # threshold the difference to create a binary motion mask
    _, motion_mask = cv2.threshold(frame_diff, 25, 255, cv2.THRESH_BINARY)

# For the connected component analysis, blob detection or hough lines detection you can use the following functions respectively:

    cv2.connectedComponents()
    cv2.SimpleBlobDetector()
    cv2.HoughLines()


# Regarding the warning sound functionality, you can improve it as following:



# To add speech synthesis to say the warning message, you can use the gTTS library which is a Python library and CLI tool to interface with Google Translate's text-to-speech API. You can install it using pip:


Copy code
    if cv2.countNonZero(closed) > 0:
        # Play a warning sound using pygame
        from gtts import gTTS
        tts = gTTS('Warning, obstacles detected')
        tts.save('warning.mp3')
        pygame.init()
        pygame.mixer.music.load("warning.mp3")
        pygame.mixer.music.play()
To send an alert to the user's phone using a library like Twilio, you first need to install the Twilio library using pip:

Copy code
pip install twilio
You also need to sign up for a Twilio account and get an account SID and an auth token.
Then you can use the Twilio library to send an SMS message to the user's phone:

Copy code
    if cv2.countNonZero(closed) > 0:
        # Send an SMS alert using Twilio
        from twilio.rest import Client
        account_sid = 'your_account_sid'
        auth_token = 'your_auth_token'
        client = Client(account_sid, auth_token)
        message = client.messages \
                                .create(
                                     body="Warning, obstacles detected",
                                     from_='your_twilio_phone_number',
                                     to='user_phone_number'
                                 )





# For obstacle detection in real-time, you can use a real-time object detection algorithm like YOLOv4-tiny or other lightweight deep learning model. You can install the YOLOv4-tiny model using the following command:


pip install yolov4
# Then, you can use the model to detect objects in the current video frame in real-time:

Copy code
import cv2
import yolov4

# Load the YOLOv4-tiny model
net = yolov4.YOLO()

while True:
    # Capture a frame from each camera
    ret0, frame0 = cap0.read()
    ret1, frame1 = cap1.read()

    # Check if the frames were successfully captured
    if not (ret0 and ret1):
        break

    # Run the YOLOv4-tiny model on the current frame
    objects = net.detect(frame0)

    # Draw bounding boxes around the detected objects
    for obj in objects:
        xmin, ymin, xmax, ymax, class_id, class_name, confidence = obj
        cv2.rectangle(frame0, (xmin, ymin), (xmax, ymax), (0, 255, 0), 2)
        cv2.putText(frame0, class_name, (xmin, ymin - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)

    # Display the current frame
    cv2.imshow("Real-time Object Detection", frame0)

    # Check if the user pressed 'q' to quit
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break



Sure, here's an example of how you can display a warning message on the screen when an obstacle is detected:

Copy code
    if cv2.countNonZero(closed) > 0:
        # Display a warning message on the screen
        cv2.putText(frame0, "Warning, obstacles detected", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)
This code will display the text "Warning, obstacles detected" on the frame0 at the position (10, 30) and using the color red. You can adjust the text, font, color, and position to suit your needs.





# here's an example of how you can display a warning message on the screen when an obstacle is detected using cv2 library:

Copy code
    if cv2.countNonZero(closed) > 0:
        # Display a warning message on the screen
        cv2.putText(frame0, "Warning, obstacles detected", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)


You can also use the cv2.rectangle function to draw a rectangle around the obstacle in the image, this will help the user to quickly locate the obstacle.

Copy code
    if cv2.countNonZero(closed) > 0:
        # Draw a rectangle around the obstacle
        cv2.rectangle(frame0, (xmin, ymin), (xmax, ymax), (0, 0, 255), 2)
You can also use the cv2.circle function to draw a circle around the obstacle in the image, this will help the user to quickly locate the obstacle.

Copy code
    if cv2.countNonZero(closed) > 0:
        # Draw a circle around the obstacle
        cv2.circle(frame0, (x_center, y_center), radius, (0, 0, 255), 2)
You can also use the cv2.arrowedLine function to draw an arrow that indicates the direction of the obstacle in the image, this will help the user to quickly locate the obstacle and avoid it.

Copy code
    if cv2.countNonZero(closed) > 0:
        # Draw an arrow that indicates the direction of the obstacle
        cv2.arrowedLine(frame0, (x_start, y_start), (x_end, y_end), (0, 0, 255), 2)


